# Works for POC, can be migrated to Redis bloom filter
import mmh3
from bitarray import bitarray

class BloomFilterStore:
    def __init__(self):
        self.filter_instances = {
           "books:1": BloomFilter()
        }

    def add(self, filter_instance: str, book_id: str) -> None:
        self.filter_instances[filter_instance].add(book_id)

    def exists(self, filter_instance: str, book_id: str) -> bool:
        return book_id in self.filter_instances[filter_instance]

class BloomFilter:
    N_HASHES = 14
    BITSET_SIZE = 1000000

    def __init__(self):
        self.bit_array = bitarray(BloomFilter.BITSET_SIZE)
        self.bit_array.setall(False)

    def add(self, item: str) -> None:
        # Set the bits generated by N_HASHES has functions -> this is signature of our item use for existence check
        for index in self._get_hashes(item):
            self.bit_array[index] = True

    def __contains__(self, item: str) -> bool:
        # We use python magic to implement existence check as in operator
        # If signature matches we consider item to be previously added (probabilistic)
        print("contains", all(self.bit_array[index] for index in self._get_hashes(item)))
        return all(self.bit_array[index] for index in self._get_hashes(item))

    def _get_hashes(self, key) -> list[int]:
        # Deterministic function to get N_HASHES hashes
        # To quickly compute 14 hashes we use double hashing (linear combination of good hashes provides a reasonable distribution of good hashes)
        hash1 = mmh3.hash(key, 42) # arbitrary seed
        hash2 = mmh3.hash(key, 7) # different arbitrary seed
        return [(hash1 + i * hash2) % BloomFilter.BITSET_SIZE for i in range(BloomFilter.N_HASHES)]
